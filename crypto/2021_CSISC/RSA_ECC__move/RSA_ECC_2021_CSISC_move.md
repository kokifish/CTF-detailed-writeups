## move

题目代码见当前目录下的``task.py``文件。题目用来一种比较特殊的方法生成公钥$e$，然后构造出一个椭圆曲线加密。其中再给出$p$中泄露出的低22比特以及第256到276这20个比特。

## 题解
题目一共分为三个步骤。
1. 根据题目中给出的代码，容易推出 
$$|\frac{e}{n} - \frac{y}{x}| < \frac{\sqrt{2}(p-q)}{36(p+q)xn^{0.25}}$$ 因为$x < \frac{1}{3}n^{0.25}$，因此有 
$$|\frac{e}{n} - \frac{y}{x}| < \frac{1}{2x^2}$$ 因此可以使用Wiener Attack来把$x$和$y$恢复出来。

2. 根据$x$和$y$和题目中给出的数学关系，恢复出$p+q$。
根据题目中的数学关系有
$$
ex = (p+1)(q+1)y + \frac{(p-q)n^{0.25}y}{3(p+1)} 
$$ 令 $$K = (ex-ny)//y = p+q+1+\frac{(p-q)n^{0.25}}{3(p+q)}$$ 则有 $$(p+q)^2 - \frac{9(p+q)^2K^2}{n^{0.5}} = (p+q)^2-(p-q)^2 = 4pq = 4n$$ 显然$K > p+q$因此我们使用二分法在区间$[0,K]$中寻找$p+q$。

3. 因为素数$p,q$都是模3余2的素数，因此以$n$为模数的椭圆曲线的阶为$(p+1)(q+1)$。从而可以很轻易求出私钥$d=e^{-1}\ mod\ (p+1)(q+1)$，以此通过密文C恢复出明文M。

代码：
```python
from Crypto.Util.number import getPrime, long_to_bytes

def get_pq(a, b, c):  # 由p+q和pq的值通过维达定理来求解p和q
    par = isqrt(b * b - 4 * a * c)  # 由上述可得，开根号一定是整数，因为有解
    x1, x2 = (-b + par) // (2 * a), (-b - par) // (2 * a)
    return x1, x2


e = 67595664083683668964629173652731210158790440033379175857028564313854014366016864587830963691802591775486321717360190604997584315420339351524880699113147436604350832401671422613906522464334532396034178284918058690365507263856479304019153987101884697932619200538492228093521576834081916538860988787322736613809
n = 80263253261445006152401958351371889864136455346002795891511487600252909606767728751977033280031100015044527491214958035106007038983560835618126173948587479951247946411421106848023637323702085026892674032294882180449860010755423988302942811352582243198025232225481839705626921264432951916313817802968185697281
h1 = 3518005
h2 = 641975
bound = int(sqrt(2 * n)) // 12

for yx in continued_fraction(e/n).convergents():
    y = yx.numerator()
    x = yx.denominator()
    if y > 1 and x < round(sqrt(bound)) and x * y < bound:
        p_plus_q = (x * e + x) // y - n - 1
        if p_plus_q < 0:
            continue
        _p = (p_plus_q + isqrt(p_plus_q ** 2 - 4 * n)) // 2
        p = int(_p)
        if int(bin(p)[2:][:22], 2) == h1:
            print(x, y)
            break

k = e*x-y*n
K = k//y
l,r = 0,K
v = 0

for i in range(515):
    s=(l+r)//2
    v=s*s-int(s*s*9*(K-1-s)*(K-1-s))//(round(n**0.25)*round(n**0.25))
    if v<4*n:
        l=s
    else:
        r=s

pandq=r
print(pandq)
d = inverse_mod(e,n+pandq+1)
Cx= 6785035174838834841914183175930647480879288136014127270387869708755060512201304812721289604897359441373759673837533885681257952731178067761309151636485456082277426056629351492198510336245951408977207910307892423796711701271285060489337800033465030600312615976587155922834617686938658973507383512257481837605
Cy= 38233052047321946362283579951524857528047793820071079629483638995357740390030253046483152584725740787856777849310333417930989050087087487329435299064039690255526263003473139694460808679743076963542716855777569123353687450350073011620347635639646034793626760244748027610309830233139635078417444771674354527028
b=(Cy**2-Cx**3)%n       # 题目定义的椭圆曲线a这一项为0，因此可以使用y^2=x^3+b求出b
E=EllipticCurve(Zmod(n), [0, b])
C=E(Cx,Cy)
P=d*C
print(P)
print(long_to_bytes(P[0]), long_to_bytes(P[1]))
```