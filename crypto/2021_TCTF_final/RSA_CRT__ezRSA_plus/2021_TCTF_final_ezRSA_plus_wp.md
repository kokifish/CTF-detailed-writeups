# 2021年TCTF_final—— Crypto —— ezRSA_plus

## 题目
见当前目录的`task.py`文件

美密会和美密会引用的一篇Bleichenbacher-May Attack的文章都可以解出这道题目。这种类型的题目为private CRT-exponents或者RSA-CRT。美密会的文章适用参数选择可以更广，但是这道题目使用Bleichenbacher-May Attack也可以得出结果。

题目生成60位的$dp,dq,k,l$，保证$(k,l)=(dp,k)=(dq,l)=1$。然后题目保证有$$e*dp\equiv 1\ mod\ k\\ e*dq\equiv 1\ mod\ l$$。然后根据公式$$p=\frac{edp-1}{k}+1 \\ q = \frac{edq-1}{l}+1$$生成$q$和$p$并保证是素数。 然后给出$(N,e)$以及$(dp,dq)$的末12位

已知密文$c$求明文$m$


题解：
使用Bleichenbacher-May Attack进行求解。根据文章的描述。已知式$$ed_p=k(p-1) \\ ed_q=l(q-1)$$相乘并展开得$$e^2d_pd_q+ed_p(l-1)+ed_q(k-1)-(N-1)kl=k+l-1$$我们令$$w = d_pd_q \\ x =d_p(l-1)+d_q(k-1) \\ y=kl \\ z=k+l-1$$则我们可以构造格$$L = \left[\begin{matrix}
1 & 0 & e\\
0 & 1 & 1-N\\
0 & 0 & e^2\\
\end{matrix}\right]$$ 因此我们有$[x\ y\ w]*L = [x\ y\ z]$，这里$[x\ y\ w]$是一个线性变换，通过LLL算法求出的最短向量将会是$[x\ y\ z]$的形式。我们不能直接对格$L$进行规约，因为还需要保证$[x\ y\ w]$有相同的大小，因此$L$需要有乘一个对角阵来平衡目标向量，即令$[x\ y\ w]$中的每个元素大小大致相同。

由于这道题目中$x,y,z$都是120bits的数，因此不需要进行平衡，直接用LLL算法得到$[x\ y\ z]$。然后使用`z3`工具求解$$y=kl \\ z=k+l-1$$然后根据
```
        assert e * d_q % l == 1
        assert e * d_p % k == 1
```
求出$d_p,d_q$，进而求出$p,q$，从而解出结果。


代码：
```python
# Sagemath 9.2
e = 1762727270442607836236621349004505613506359415168929966540357011133047321101203605340201016757203407375680206339341465088639129039278027484128644822299382121442456525803635369125157261704416172232695058332167310707999473221769390010733123910955508477009411113166141188309425895082608534271594076218827
n = 5943169364392579648240628105465400265561630477719849140342288893646282358845864829196464904298425034495515703590715696166689341849788423790118035115884268058450057766891418761627136386260375534474238287294722575087291704432681906513559934960801746158191355141430407698622886747610818853554584519369492697299961587570531415598410602926850787615266600194130088653542080297272898142822126215764285317511778718862825024939241749996811603610592132845393755564618871967716819173935553139267269362451423802419847919801412517294612793840767037662589233422389282092051866024514599213445596030685325227269609799

m = Matrix(ZZ, 3, 3)
m[0,0] = 1
m[0,2] = e
m[1,1] = 1
m[1,2] = 1-n
m[2,2] = e*e

ml = m.LLL()
ttt = ml.rows() 
print(ttt[0])
# (-1142686296663302040904254892681058527, -413115081856988922174674736272604552, -1287298866011486656)

import z3
k = z3.Int('k')
l = z3.Int('l')
s = z3.Solver()
s.add(k*l == 413115081856988922174674736272604552)
s.add(k+l-1 == 1287298866011486656)
print(s.check())
print(s.model())

k = 609451322654059464
l = 677847543357427193
enc = 4531542437692818645025309324015912433184165181252393791711464775823247402127139569010657935303362440253951226047224610112010632226435610975118324658493911658016955717228741291266124372004503735693124810068041692730706167827666860062121413284053921548345924563903211959003376490264228814415500106847482893238907846512437694006785527867729127228361388592714377847012086312471372061723017560705890925568994607972832373362380226566506368932968108567819188587148829190811891555283157485379418388715910299951228404648535235675640369275644493614250037857212768450860647393276921502407057557208885073276533644
from Crypto.Util.number import long_to_bytes


for i in range(0,5):
    dp = inverse_mod(e, k)+i*k
    for j in range(0,5):
        dq = inverse_mod(e, l) + j*l
        p = (e * dp - 1) // k + 1
        q = (e * dq - 1) // l + 1
        if is_prime(p) and is_prime(q):
            print(p,q)
            phi_n = (p-1)*(q-1)
            d = inverse_mod(e, phi_n)
            m = power_mod(enc, d, n)
            print(long_to_bytes(m))
            break
            
# flag{s0rry_4_the_si11y_mis7ak3!!!}
```


参考writeup: 
* https://zhuanlan.zhihu.com/p/415453702
* https://l.xdsec.org/archives/385.html
* https://www.iacr.org/archive/crypto2007/46220388/46220388.pdf **2007美密会**
* https://link.springer.com/content/pdf/10.1007%2F11745853_1 **Bleichenbacher-May Attack**