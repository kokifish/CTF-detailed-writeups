# 2021年TCTF_final—— Crypto —— ezRSA

## 题目
见当前目录的`task.py`文件

本质上这是一道很简单的rsa，但是不看wp我还真没有留意到那些简单的解法。但是实际上这是一种特殊的RSA设计方法，本质上是2007年美密会的一个攻击RSA的方案，然后这道题目根据该方案的密钥生成算法选取RSA的参数，理论上是可以用美密会的方案解出来的。但是题目中给出了一个magic的提示，导致不使用美密会的方案也能解出这道题。这场比赛的另一道题`ezRSA_plus`就设计成一定要用到那个方案。

题目生成60位的$dp,dq,k,l$，保证$(k,l)=(dp,k)=(dq,l)=1$。然后题目保证有$$e*dp\equiv 1\ mod\ k\\ e*dq\equiv 1\ mod\ l$$。然后根据公式$$p=\frac{edp-1}{k}+1 \\ q = \frac{edq-1}{l}+1$$生成$q$和$p$并保证是素数。 然后给出$(N,e)$以及$(dp,dq)$的末10位， 并给出$$magic = 1337k^4+7331l^3+73331k^2+13337l^2+7kl+2k+l$$。

已知密文$c$求明文$m$


题解：
对magic开4次方得到近似的$k$，然后遍历$k$的左右找到确定的$k$。因为$k$一变，$$magic-1337*k^4$开三次方根会变化很大，没有太高的参考价值。因此使用二分法在$[0,2^{61}]$中找合适的$l$。

* 另一个解法：直接用`z3`把$k,l$解出来。

关键一步：已知$$e*dp\equiv 1\ mod\ k\\ e*dq\equiv 1\ mod\ l$$，因此可以用$e$对$k,l$进行求逆得到$dp,dq$。注意得到的$dp,dq$是模$k,l$的结果，可能需要加上一定数量的$k,l$。

得到$dp,dq$后可以恢复得到$p,q$从而解出题目。

代码：
```python
from Crypto.Util.number import *
import gmpy2

def run_magic(kk, ll):
    return 1337 * kk ** 4 + 7331 * ll ** 3 + 73331 * kk ** 2 + 13337 * ll ** 2 + 7 * kk * ll + 2 * kk + ll


(n,e)=(13144833961692953638155744717380612667335058302310815242506755676885208234342620331186804951145894484501542968789132832800279633590988848298405521677820600481054741175400784558190943019903268095468121342412114428860754522164657102624139527993254089574309927288457799155130004731846999722554981630609692264462023821778810225493633789543259034893395115658330417361250466876018981150507377427664192443342394808337473089411393262018525828475108149889915075872592673448211565529063972264324533136645650169687118301014325354524932405270872098633633071371124551496573869700120350489760340226474892703585296623, 4976865541630914024304930292600669330017247151290783019063407119314069119952298933566289617702551408322779629557316539138884407655160925920670189379289389411163083468782698396121446186733546486790309424372952321446384824084362527492399667929050403530173432700957192011119967010196844119305465574740437)
(magic,dp_mask, dq_mask)=(154118536863381755324327990994045278493514334577571515646858907141541837890, 431, 217)
enc = 12075538182684677737023332074837542797880423774993595442794806087281173669267997104408555839686283996516133283992342507757326913240132429242004071236464149863112788729225204797295863969020348408992315952963166814392745345811848977394200562308125908479180595553832800151118160338048296786712765863667672764499042391263351628529676289293121487926074423104988380291130127694041802572569416584214743544288441507782008422389394379332477148914009173609753877263990429988651290402630935296993764147874437465394433756515223371180032964253037946818633821940103044535390973722964105390263537722948112571112911062

k = gmpy2.iroot(magic//1337, 4)[0]
lf = 0

for i in range(-10,10):
    k1 = k + i
    # if (magic - 1337*k1**4) <=0:
    #     continue
    l,r = 0, 2**62
    while l <= r:
        mid = (l+r)//2
        if run_magic(k1, mid) < magic:
            l = mid+1
        elif run_magic(k1,mid) > magic:
            r = mid-1
        else:
            print(mid)
            k = k1
            lf = mid
            break

print(k, lf)

# 因为dp,dq和k,l的比特数相近，因为dq,dp是模k了的，因此可能要加上一两个k或l，需要不断尝试
dp = gmpy2.invert(e, k)+k
dq = gmpy2.invert(e, lf)

e1 = inverse(dp, k) * inverse(lf, k) * lf + inverse(dq, lf) * inverse(k, lf) * k

p = (e * dp - 1) // k + 1
q = (e * dq - 1) // lf + 1

print(gmpy2.is_prime(p), gmpy2.is_prime(q))

InvQ = gmpy2.invert(q, p)
mp = pow(enc, dp, p)
mq = pow(enc, dq, q)
m = (((mp - mq) * InvQ) % p) * q + mq

print(long_to_bytes(m))

```


参考writeup: 
* https://zhuanlan.zhihu.com/p/415453702
* https://l.xdsec.org/archives/385.html